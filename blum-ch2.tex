\documentclass[twoside]{article}
\setlength{\oddsidemargin}{0.25 in}
\setlength{\evensidemargin}{-0.25 in}
\setlength{\topmargin}{-0.6 in}
\setlength{\textwidth}{6.5 in}
\setlength{\textheight}{8.5 in}
\setlength{\headsep}{0.75 in}
\setlength{\parindent}{0 in}
\setlength{\parskip}{0.1 in}

%
% ADD PACKAGES here:
%
\usepackage{amsmath,amsfonts,graphicx}

%
% The following commands set up the lecnum (lecture number)
% counter and make various numbering schemes work relative
% to the lecture number.
%
\renewcommand{\thepage}{\arabic{page}}
\renewcommand{\thesection}{\arabic{section}}
\renewcommand{\theequation}{\arabic{equation}}
\renewcommand{\thefigure}{\arabic{figure}}
\renewcommand{\thetable}{\arabic{table}}

%
% The following macro is used to generate the header.
%
\newcommand{\head}[2]{
   \pagestyle{myheadings}
   \thispagestyle{plain}
   \newpage
   \noindent
   \begin{center}
   \framebox{
      \vbox{\vspace{2mm}
    \hbox to 6.28in { {\bf Scott Sanderson
		\hfill Source: \cite{#1} }}
       \vspace{4mm}
       \hbox to 6.28in { {\Large \hfill #2 \hfill} }
       \vspace{2mm}
       \hbox to 6.28in { { \hfill Date: \today} }
      \vspace{2mm}}
   }
   \end{center}
   
   \vspace*{4mm}
}

% Thesis Commands

\newcommand{\inspace}[0]{\mathcal{I}}
\newcommand{\outspace}[0]{\mathcal{O}}
\newcommand{\statespace}[0]{\mathcal{S}}
\newcommand{\nodes}[0]{\mathcal{N}}
\newcommand{\fullstate}[0]{\nodes \times \statespace}
\newcommand{\nodein}[0]{\nodes_{in}}
\newcommand{\nodeout}[0]{\nodes_{out}}

\newcommand{\reals}[0]{\mathbb{R}}
\newcommand{\complexes}[0]{\mathbb{C}}
\newcommand{\set}[1]{\{#1\}}

\newcommand{\functype}[3]{$#1:#2 \rightarrow #3$} 
\newcommand{\mfunctype}[3]{#1:#2 \rightarrow #3} 
\newcommand{\computefn}[0]{\Phi}
\newcommand{\note}[1]{{\textbf{Note:} #1}}
\newcommand{\compute}[0]{\phi}
\newcommand{\computeout}[0]{\phi_{out}}
\newcommand{\computepath}[0]{\gamma}
\newcommand{\pathprojection}[0]{\pi_\nodes}
\newcommand{\stateprojection}[0]{\pi_\statespace}

%
% Convention for citations is authors' initials followed by the year.
% For example, to cite a paper by Leighton and Maggs you would type
% \cite{LM89}, and to cite a paper by Strassen you would type \cite{S69}.
% (To avoid bibliography problems, for now we redefine the \cite command.)
% Also commands that create a suitable format for the reference list.
\renewcommand{\cite}[1]{[#1]}
\def\beginrefs{\begin{list}%
        {[\arabic{equation}]}{\usecounter{equation}
         \setlength{\leftmargin}{2.0truecm}\setlength{\labelsep}{0.4truecm}%
         \setlength{\labelwidth}{1.6truecm}}}
\def\endrefs{\end{list}}
\def\bibentry#1{\item[\hbox{[#1]}]}

%Use this command for a figure; it puts a figure in wherever you want it.
%usage: \fig{NUMBER}{SPACE-IN-INCHES}{CAPTION}
\newcommand{\fig}[3]{
			\vspace{#2}
			\begin{center}
			Figure \thelecnum.#1:~#3
			\end{center}
	}
% Use these for theorems, lemmas, proofs, etc.
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}[theorem]{Definition}
\newenvironment{proof}{{\bf Proof:}}{\hfill\rule{2mm}{2mm}}

\begin{document}
%FILL IN THE RIGHT INFO.
%\head{**Title**}{**Date**}
\head{B98}{Chap 2 - Definitions and First Properties of Computation}
%\footnotetext{These notes are partially based on those of Nigel Mansell.}

% **** YOUR NOTES GO HERE:

% Some general latex examples and examples making use of the
% macros follow.  
%**** IN GENERAL, BE BRIEF. LONG SCRIBE NOTES, NO MATTER HOW WELL WRITTEN,
%**** ARE NEVER READ BY ANYBODY.


\section{A Finite Dimensional Model of Computation}

The basic idea that we want to formalize with a Finite Dimensional
Machine is that of an algorithm over a ring that consists in
repeatedly iterating a set of polynomial functions over elements of
the ring.  The canonical motivating example is Newton's Method over
$\reals^2$, which approximates the zeros of an arbitrary polynomial by
repeatedly calculating an associated polynomial function on a start
value until the resulting value is less than some $\epsilon$ (and thus
presumably close to a zero of the polynomial).  The core elements of
such an algorithm are:

\begin{enumerate}
  \item A set of inputs over which the algorithm is defined.

  \item A set of values that can be stored by the algorithm for
    future computations.

  \item A function or set of functions to perform calculations on the
    stored values.

  \item A decision function or set of decision functions to determine
    which calculation to perform at a given time

  \item A set of values for the algorithm to output.
\end{enumerate}

We present two equivalent definitions of a Finite Dimensional Machine.
The first is nearly a direct transcription of the definition given by
\cite{B98}.  The second is a version which replaces the directed graph
in the first definition with a specification of what Blum et al. call
the computing endomorphism.  The primary motivation behind this change
is to facilitate a more natural extension to the non-deterministic
case.

\subsection{Definitions}

Let $R$ be a commutative ring with unit, and let $l, m, n$ be positive
integers.  By convention, we use the letter $p$ to denote a polynomial
over $R$, and we denote the ring of polynomials over $R$ of degree $k$
by $R^k$. 

\begin{definition}{\textbf{Finite Dimensional Machine} over a ring
    \textbf{R} (as defined in \cite{B98})}

  A \textbf{Finite Dimensional Machine} (FDM), $M$ over $R$ is a
  finite, directed, connected graph with four types of nodes:
  \emph{input, computation, branch} and \emph{output}.  An FDM has one
  input and one output node, and can have any number of branch and
  computation nodes. The input node has indegree 0.  All other nodes
  have indegree $\geq$ 1. The input node and computation nodes have
  outdegree 1; branch nodes have outdegree 2, and the output node has
  outdegree 0.  We will use the expression ``next node'' of a node
  $\beta$ to refer to the nodes to which $\beta$ has outgoing edges.\\

  \emph{\note{Blum et al. allow a machine to have multiple
    output nodes, but it is relatively easy to show that any machine
    with multiple output nodes can be trivially reduced to a machine
    with a single output node, so for ease of notation we
    prefer the single output notation here.}}\\

  An FDM also has three associated spaces: an input space $\inspace_M
  \subseteq R^n$, a state space $\statespace_M \subseteq R^m$, and an
  output space $\outspace_M \subseteq R^l$.  (Recall that $R^k$
  denotes the ring of polynomials over $R$ with degree at most $k$).\\

  Each node has an associated map, which varies in structure in
  accordance with its type.
  \begin{enumerate}
  \item Associated with the input node is a linear map
    \functype{I}{\inspace_M}{\statespace_M}. We denote the next node
    of the input node by $\beta_1$.

  \item Associated with each computation node, $\eta$, is a polynomial
    map \functype{g_\eta}{\statespace_M}{\statespace_M}. We denote the
    next node of $\eta$ by $\beta_\eta$.

  \item Associated with each branch node, $b$ is a nonzero polynomial
    function \functype{g_b}{\statespace_M}{R}.  We associate the
    condition $g_b(p) \geq 0$ with one of the next nodes of $b$,
    called the \textbf{Yes Node} of $b$.  We symbolically denote the Yes Node by $\beta_b^+$. We
    associate the condition $g_b(p) < 0$ with the remaining next node of $b$, which we call the 
    \textbf{No Node} and denote $\beta_b^-$. 

  \item Associated with the output node is a linear map
    \functype{O}{\statespace_M}{\outspace_M}.

  \end{enumerate}
\end{definition}

Blum et al's definition is meant to capture a intuition that a real
algorithm corresponds to a kind of flowchart, in which we follow the
flowchart and perform specific computations depending on what we've
already computed.  

\begin{definition}{\textbf{Finite Dimensional Machine} over a ring \textbf{R}}

  A \textbf{Finite Dimensional Machine} (FDM) over $R$ is a tuple,
  $(\inspace, \statespace, \outspace, \nodes, H, H_{in}, H_{out})$, where:

  \begin{enumerate}

  \item $\inspace \subseteq R^l$ is the \textbf{Input Space} of M.

  \item $\statespace \subseteq R^m$ is the \textbf{State Space} of M.

  \item $\outspace \subseteq R^n$ is the \textbf{Output Space} of M.

  \item $\nodes$ is a finite set of nodes given by: $ \nodes =
    \set{\nodein, \nodeout} \cup \set{\eta_1, \eta_2, \ldots \eta_i}
    \cup \set{b_1, b_2, \ldots b_j}$, where $\nodes_{in}$ is the
    unique \textbf{Input Node}, $\nodeout$ is the unique
    \textbf{Output Node}, $\set{\eta_1, \eta_2, \ldots \eta_i}$ is the
    set of \textbf{Computation Nodes}, and $ \set{b_1, b_2, \ldots b_j}$
    is the set of \textbf{Branching Nodes}.

  \item \functype{H_{in}}{\inspace}{\nodein \times \statespace} is a
    linear map called the \textbf{Input Map} of $M$.

  \item \functype{H}{\nodes \times \statespace}{\nodes \times
      \statespace} is the \textbf{Computing Endomorphism} of $M$.

  \item \functype{H_{out}}{\nodeout \times \statespace}{\outspace} is
    a linear map called the \textbf{Output Map} of $M$.

  \end{enumerate}

\end{definition}

  \note{By convention, we will use the symbol $\beta$ to refer to a node
    when we do not wish to distinguish between types.}

  \subsubsection{Properties of the computing endomorphism, $H$}

  The computing endomorphism abstracts the process of either
  performing a computation on our currently stored information or
  making a decision about which computation to perform next.  Each
  computation node in $\nodes$ represents a state of our algorithm in
  which we want to perform a specific computation.  Each branching
  node represents a state in which we need to decide which computation
  to perform next.  Since each computation node represents a specific computation and
  each branching node represents a specific decision procedure, we add the following 
  restrictions to $H$.

  \begin{enumerate}

  \item For each computation node, $\eta$, there exists a unique node,
    $\beta_\eta$ and a polynomial map
    \functype{g_\eta}{\statespace}{\statespace}, such that $H(\eta, p)
    = (\beta_\eta, g_\eta(p)) \mid \forall p \in \statespace$.  We
    refer to $g_\eta$ as the \textbf{Computation Map} of $\eta$.

  \item For each branch node, $b$, there exist a pair of nodes,
    $\beta_b^+$ and $\beta_b^-$, and a non-zero polynomial map,
    \functype{g_b}{\statespace}{R}, such that $H(b, p) = (\beta_b^+,
    p)$ if $g_b \geq 0$ and $H(b,p) = (\beta_b^-, p)$ if $g_b < 0$.
    We refer to $g_b$ as the \textbf{Branching Function} of $b$, and
    we refer to $\beta_b^+$ and $\beta_b^-$ respectively as the
    \textbf{Yes Node} and \textbf{No Node} of $b$.

  \end{enumerate}

  \begin{definition}{\textbf{Computation of an FDM on input $p$}}\\
    
    The \textbf{Computation}, $\compute_p$, of an FDM, $M$, on input
    $p \in \inspace$ is the sequence $z^0, z^1, z^2, \ldots, \computeout$,
    where $z^0$ = $(\nodein, p)$, $z^1$ = $H(\nodein, p)$, $z^2 =
    H(z^1) \ldots$, and $\computeout$ is the first value in $\outspace$
    obtained by successive iterates of $H$.

    \emph{\note{Successive iterations of $H$ on input $p$ need
        not ever take on a value in $\outspace$.  In particular, $M$
        may enter an infinite loop.  In such a case, we say that the
        computation of of $M$ on $p$ is undefined.}}\\

    The \textbf{Computation Function} or \textbf{I/O Map},
    \functype{\computefn}{\inspace}{\outspace} of $M$ is
    given by: $\computefn(p) = \compute_p \mid  p \in \inspace$
  \end{definition}

  \begin{definition}{\textbf{Computation Path} and \textbf{State Trajectory}}\\
    
    The \textbf{Computation Path}, $\computepath_p$, of $M$ on
    input $p$ is the projection of $\compute_p$ under the map:
    $$\mfunctype{\pathprojection}{\fullstate}{\nodes} \mid \pathprojection(\beta, p) = \beta$$
    
    The \textbf{State Trajectory} of an FDM $M$ on input $p$ is the
    projection of $\compute_p$ under the map:
    $$\mfunctype{\stateprojection}{\fullstate}{\nodes} \mid \stateprojection(\beta, p) = p$$
  \end{definition}

  \begin{definition}
    
  \end{definition}


\section*{References}
\beginrefs

% Sample citation, to be cited at by calling \cite{CW87}

% \bibentry{CW87}{\sc D.~Coppersmith} and {\sc S.~Winograd}, 
% ``Matrix multiplication via arithmetic progressions,''
% {\it Proceedings of the 19th ACM Symposium on Theory of Computing},
% 1987, pp.~1--6.

\bibentry{B98}{\sc Blum et al.},
``Complexity and Real Computation,''
{\it Springer-Verlag New York, Inc.}
1998, pp. 37-69


\endrefs

% **** THIS ENDS THE EXAMPLES. DON'T DELETE THE FOLLOWING LINE:

\end{document}





